/**
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

"use strict";

const outdir = 'ast/';

let fs = require('fs');

let Spec = require('./consume-spec').default;
let nodes = Spec.nodes;
let enums = Spec.enums;
let namedTypes = Spec.namedTypes;

let namedTypeInherits = new Map;

const enumImports = new Map([
  ['CompoundAssignmentOperator', 'com.shapesecurity.shift.ast.operators.CompoundAssignmentOperator'],
  ['BinaryOperator', 'com.shapesecurity.shift.ast.operators.BinaryOperator'],
  ['UnaryOperator', 'com.shapesecurity.shift.ast.operators.UnaryOperator'],
  ['UpdateOperator', 'com.shapesecurity.shift.ast.operators.UpdateOperator'],
  ['VariableDeclarationKind', 'com.shapesecurity.shift.ast.VariableDeclarationKind']
]);


const forbiddenNames = ['super']
function sanitize(str) {
  return forbiddenNames.indexOf(str) === -1 ? str : `_${str}`; // todo this is a bit dumb - what other names are reserved in Java?
}

function inherits(child, parent) {
  let parents = nodes.get(child).parents;
  if (parents.indexOf(parent) === -1) {
    parents.push(parent);
  }
}

function isJavaInterfaceType(name) {
  let type = nodes.get(name);
  return type.attributes.length === 0 && !type.isLeaf;
}

function toJavaType(type) {
  switch (type.kind) {
    case 'nullable':
      return `Maybe<${toJavaType(type.argument)}>`;
    case 'union':
      return type.argument.map(t => t.argument).join('');
    case 'list':
      return `ImmutableList<${toJavaType(type.argument)}>`;
    case 'namedType':
      let desc = type;
      while (desc.kind === 'namedType') {
        desc = namedTypes.get(desc.argument);
      }
      if (desc.kind === 'value' || desc.kind === 'list') {
        return toJavaType(desc);
      }
      if (nodes.has(type.argument)) {
        return type.argument;        
      } else {
        throw `Unknown type ${JSON.stringify(type)}`;
      }
    case 'value':
      switch (type.argument) {
        case 'string':
          return 'String';
        case 'boolean':
          return 'boolean';
        case 'double':
          return 'double';
        default:
          throw `Unhandled value type ${type.argument}`;
      }
    case 'node':
    case 'enum':
      return type.argument;
  }
}

namedTypes.forEach((type, name) => {
  switch (type.kind) {
    case 'union':
      nodes.set(name, {isLeaf: false, parents: [], attributes: []});
      break;
  }
});

namedTypes.forEach((type, name) => {
  switch (type.kind) {
    case 'union':
      nodes.set(name, {isLeaf: false, parents: [], attributes: []});
      type.argument.forEach(t => {inherits(t.argument, name);});
      break;
  }
});

let seen = new Set;
function addUnions(type) {
  if (seen.has(type)) return;
  seen.add(type);
  switch (type.kind) {
    case 'nullable':
    case 'list':
      addUnions(type.argument);
      break;
    case 'namedType':
      let child = namedTypes.get(type.argument);
      switch (child.kind) {
        case 'union':
          child.argument.forEach(t => {
            if (t.kind === 'node') {
              inherits(t.argument, type.argument);
            } else if (t.kind === 'namedType') {
              inherits(t.argument, type.argument);
            } else {
              throw `Union of unhandled type ${JSON.stringify(t)}`;
            }
          });
          break;
        default:
          addUnions(child);
      }
      break;
    case 'union':
      let name = type.argument.map(t => t.argument).join('');
      nodes.set(name, {isLeaf: false, parents: [], attributes: []});
      type.argument.forEach(t => {
        if (t.kind === 'node') {
          inherits(t.argument, name);
        } else if (t.kind === 'namedType') {
          inherits(t.argument, name);
        } else {
          throw `Union of unhandled type ${JSON.stringify(t)}`;
        }
      });
      break;
  }
}

nodes.forEach(n => {
  n.attributes.forEach(a => addUnions(a.type));
});


const header = `// Generated by shift-java-gen/ast.JSON

/*
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.shapesecurity.shift.ast;
`;

// actually generate the files
for (let n of Array.from(nodes.keys()).filter(n => !isJavaInterfaceType(n))) {
  let node = nodes.get(n);

  let imp = node.parents.filter(isJavaInterfaceType);
  let imps = imp.length > 0 ? ` implements ${imp.join(', ')}` : ''; // todo consider removing redundant `Node`s
  let ex = node.parents.filter(n => !isJavaInterfaceType(n));
  if (ex.length > 1) {
    throw `${n} extends multiple types`;
  }
  let exs = ex.length === 1 ? ` extends ${ex}` : '';

  let attrs = node.attributes;
  attrs.forEach(a => {a.name = sanitize(a.name); a.type = toJavaType(a.type);});

  let fields = attrs.filter(a => !a.inherited).map(a => `    @NotNull
    public final ${a.type} ${a.name};
`).join('\n');

  let ctorBodyLines = ex.length === 1 ? [`        super(${attrs.filter(a => a.inherited).map(a => a.name).join(', ')});`] : [];
  ctorBodyLines.push(...attrs.filter(a => !a.inherited).map(a => `        this.${a.name} = ${a.name};`));

  let ctorBody = ctorBodyLines.length > 0 ? `\n${ctorBodyLines.join('\n')}\n    ` : '';

  let ctor = `
    public ${n} (${attrs.map(a => `${a.type === 'boolean' ? '' : '@NotNull '}${a.type} ${a.name}`).join(', ')}) {${ctorBody}}
`;

  let imports = `
import org.jetbrains.annotations.NotNull;
import com.shapesecurity.functional.data.HashCodeBuilder;
` + 
    (attrs.some(a => a.type.match('ImmutableList')) ? 'import com.shapesecurity.functional.data.ImmutableList;\n' : '') +
    (attrs.some(a => a.type.match('Maybe')) ? 'import com.shapesecurity.functional.data.Maybe;\n' : '') +
    (attrs.filter(a => !a.inherited && enums.has(a.type)).map(a => `import ${enumImports.get(a.type)};\n`));


  let propEquals = a => a.type === 'boolean' || a.type === 'double' ? ` && this.${a.name} == ((${n}) object).${a.name}` : ` && this.${a.name}.equals(((${n}) object).${a.name})`;
  let equals = `
    @Override
    public boolean equals(Object object) {
        return object instanceof ${n}${attrs.map(propEquals).join('')};
    }
`;
  
  let hashCode = `
    @Override
    public int hashCode() {
        int code = HashCodeBuilder.put(0, "${n}");${attrs.map(a => `\n        code = HashCodeBuilder.put(code, this.${a.name});`).join('')}
        return code;
    }
`;

  let clazz = `${header}${imports}
public class ${n}${exs}${imps} {
${fields}
${ctor}
${equals}
${hashCode}
}
`;
  fs.writeFile(outdir + n + '.java', clazz, 'utf8', ()=>{});
}


for (let n of Array.from(nodes.keys()).filter(isJavaInterfaceType)) {
  let node = nodes.get(n);

  let imp = node.parents.filter(isJavaInterfaceType);
  if (imp.length !== node.parents.length) {
    throw `Interface type ${n} extends some type`;
  }

  if (n !== 'Node' && imp.length === 0) {
    imp = ['Node'];
  }

  let imps = imp.length > 0 ? ` extends ${imp.join(', ')}` : ''; // todo consider removing redundant `Node`s
  let body = `${header}
public interface ${n}${imps} {}
`
  fs.writeFile(outdir + n + '.java', body, 'utf8', ()=>{});
}


console.log(nodes.get('ArrayAssignmentTarget'))

